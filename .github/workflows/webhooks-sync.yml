name: üîó Webhooks & Sincroniza√ß√£o

on:
  push:
    branches: [ main, develop ]
  deployment_status:
  repository_dispatch:
    types: [webhook-trigger, sync-request]
  workflow_dispatch:
    inputs:
      sync_type:
        description: 'Tipo de sincroniza√ß√£o'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - partial
        - metadata

env:
  WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}

jobs:
  # üîÑ Sincroniza√ß√£o de Deploy
  deploy-sync:
    name: üîÑ Deploy Sync
    runs-on: ubuntu-latest
    if: github.event_name == 'deployment_status'
    
    steps:
    - name: üì° Webhook Deploy Status
      run: |
        echo "Deploy Status: ${{ github.event.deployment_status.state }}"
        echo "Environment: ${{ github.event.deployment_status.environment }}"
        echo "URL: ${{ github.event.deployment_status.target_url }}"

    - name: üåê Notify External Services
      run: |
        # Notificar servi√ßos externos sobre deploy
        curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
          -H "Content-Type: application/json" \
          -d "{
            \"text\": \"üöÄ Deploy realizado no ambiente **${{ github.event.deployment_status.environment }}**\",
            \"attachments\": [{
              \"color\": \"${{ github.event.deployment_status.state == 'success' && 'good' || 'danger' }}\",
              \"fields\": [{
                \"title\": \"Status\",
                \"value\": \"${{ github.event.deployment_status.state }}\",
                \"short\": true
              }, {
                \"title\": \"URL\",
                \"value\": \"${{ github.event.deployment_status.target_url }}\",
                \"short\": true
              }]
            }]
          }" || echo "Slack webhook n√£o configurado"

    - name: üìä Update Metrics
      run: |
        # Atualizar m√©tricas de deploy
        echo "Updating deployment metrics..."
        echo "Deploy Count: $(date +%s)" > deployment_metrics.json

  # üîó Processamento de Webhooks
  webhook-processor:
    name: üîó Webhook Processor
    runs-on: ubuntu-latest
    if: github.event_name == 'repository_dispatch'
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: üîç Process Webhook Data
      id: process
      run: |
        echo "Event Type: ${{ github.event.action }}"
        echo "Client Payload: ${{ toJson(github.event.client_payload) }}"
        
        # Processar diferentes tipos de webhook
        case "${{ github.event.action }}" in
          "webhook-trigger")
            echo "webhook_type=external" >> $GITHUB_OUTPUT
            ;;
          "sync-request")
            echo "webhook_type=sync" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "webhook_type=unknown" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: üîÑ External Webhook Handler
      if: steps.process.outputs.webhook_type == 'external'
      run: |
        echo "Processing external webhook..."
        # Processar webhook de servi√ßos externos (Discord, Slack, etc.)
        
        # Exemplo: Discord webhook
        if [[ -n "${{ secrets.DISCORD_WEBHOOK }}" ]]; then
          curl -H "Content-Type: application/json" \
               -d "{\"content\":\"üì° Webhook recebido: ${{ toJson(github.event.client_payload) }}\"}" \
               ${{ secrets.DISCORD_WEBHOOK }}
        fi

    - name: üîÑ Sync Request Handler
      if: steps.process.outputs.webhook_type == 'sync'
      run: |
        echo "Processing sync request..."
        # Sincronizar dados com APIs externas
        
        # Exemplo: Sincronizar com banco de dados
        curl -X POST https://api.l3trament0.com/sync \
          -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d "{
            \"repository\": \"${{ github.repository }}\",
            \"branch\": \"${{ github.ref_name }}\",
            \"commit\": \"${{ github.sha }}\",
            \"timestamp\": \"$(date -Iseconds)\"
          }" || echo "API sync failed"

  # üì° Monitoramento de Uptime
  uptime-monitor:
    name: üì° Uptime Monitor
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    
    steps:
    - name: üåê Check Production Sites
      id: uptime
      run: |
        # Verificar status dos sites
        VERCEL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://l3trament0web3.vercel.app || echo "000")
        NETLIFY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://l3trament0web3.netlify.app || echo "000")
        GITHUB_PAGES_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://catitodev.github.io/l3trament0web3 || echo "000")
        
        echo "vercel_status=$VERCEL_STATUS" >> $GITHUB_OUTPUT
        echo "netlify_status=$NETLIFY_STATUS" >> $GITHUB_OUTPUT
        echo "github_pages_status=$GITHUB_PAGES_STATUS" >> $GITHUB_OUTPUT

    - name: üö® Alert on Down Sites
      if: steps.uptime.outputs.vercel_status != '200' || steps.uptime.outputs.netlify_status != '200'
      run: |
        # Alertar sobre sites fora do ar
        MESSAGE="üö® **ALERTA**: Alguns sites est√£o fora do ar!
        
        - Vercel: ${{ steps.uptime.outputs.vercel_status == '200' && '‚úÖ' || '‚ùå' }} (${{ steps.uptime.outputs.vercel_status }})
        - Netlify: ${{ steps.uptime.outputs.netlify_status == '200' && '‚úÖ' || '‚ùå' }} (${{ steps.uptime.outputs.netlify_status }})
        - GitHub Pages: ${{ steps.uptime.outputs.github_pages_status == '200' && '‚úÖ' || '‚ùå' }} (${{ steps.uptime.outputs.github_pages_status }})
        
        Timestamp: $(date)"
        
        # Discord alert
        if [[ -n "${{ secrets.DISCORD_WEBHOOK }}" ]]; then
          curl -H "Content-Type: application/json" \
               -d "{\"content\":\"$MESSAGE\"}" \
               ${{ secrets.DISCORD_WEBHOOK }}
        fi

    - name: üìä Update Status Page
      run: |
        # Atualizar p√°gina de status
        cat > status.json << EOF
        {
          "timestamp": "$(date -Iseconds)",
          "services": {
            "vercel": {
              "status": "${{ steps.uptime.outputs.vercel_status }}",
              "healthy": ${{ steps.uptime.outputs.vercel_status == '200' && 'true' || 'false' }}
            },
            "netlify": {
              "status": "${{ steps.uptime.outputs.netlify_status }}",
              "healthy": ${{ steps.uptime.outputs.netlify_status == '200' && 'true' || 'false' }}
            },
            "github_pages": {
              "status": "${{ steps.uptime.outputs.github_pages_status }}",
              "healthy": ${{ steps.uptime.outputs.github_pages_status == '200' && 'true' || 'false' }}
            }
          }
        }
        EOF

  # üîÑ Backup Autom√°tico
  auto-backup:
    name: üîÑ Backup Autom√°tico
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: üì¶ Create Backup
      run: |
        # Criar backup do reposit√≥rio
        BACKUP_NAME="l3trament0web3-backup-$(date +%Y%m%d-%H%M%S)"
        
        # Criar bundle Git
        git bundle create ${BACKUP_NAME}.bundle --all
        
        # Criar tar.gz do c√≥digo fonte
        tar -czf ${BACKUP_NAME}-source.tar.gz \
          --exclude=node_modules \
          --exclude=.git \
          --exclude=dist \
          .

    - name: ‚òÅÔ∏è Upload to Cloud Storage
      run: |
        # Upload para cloud storage (exemplo com curl)
        echo "Uploading backup to cloud storage..."
        
        # Simular upload (substitua pela API real)
        curl -X POST https://backup-api.example.com/upload \
          -H "Authorization: Bearer ${{ secrets.BACKUP_TOKEN }}" \
          -F "file=@l3trament0web3-backup-$(date +%Y%m%d-%H%M%S).bundle" \
          || echo "Backup upload failed"

  # üîî Sistema de Notifica√ß√µes
  notification-system:
    name: üîî Notifica√ß√µes
    runs-on: ubuntu-latest
    needs: [deploy-sync, webhook-processor, uptime-monitor]
    if: always()
    
    steps:
    - name: üìä Generate Status Report
      run: |
        echo "## üìä Relat√≥rio de Sincroniza√ß√£o" >> $GITHUB_STEP_SUMMARY
        echo "- **Deploy Sync**: ${{ needs.deploy-sync.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Webhook Processor**: ${{ needs.webhook-processor.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Uptime Monitor**: ${{ needs.uptime-monitor.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp**: $(date)" >> $GITHUB_STEP_SUMMARY

    - name: üåê Send Notifications
      run: |
        # Enviar notifica√ß√µes para m√∫ltiplos canais
        SUMMARY="üîó **Sincroniza√ß√£o L3trament0Web3**
        
        Status dos servi√ßos:
        - Deploy Sync: ${{ needs.deploy-sync.result }}
        - Webhooks: ${{ needs.webhook-processor.result }}
        - Monitoramento: ${{ needs.uptime-monitor.result }}
        
        $(date)"
        
        # Discord
        if [[ -n "${{ secrets.DISCORD_WEBHOOK }}" ]]; then
          curl -H "Content-Type: application/json" \
               -d "{\"content\":\"$SUMMARY\"}" \
               ${{ secrets.DISCORD_WEBHOOK }}
        fi
        
        # Telegram
        if [[ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]] && [[ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]]; then
          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
               -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}&text=$SUMMARY"
        fi